# ----------------------------------------------------------------------------------------
# File: .github/workflows/secrets-example.yml
#
# Workflow Name: secrets-example
#
# Description:
# Demonstrates how to reference and use GitHub Actions secrets safely. Shows:
#   1) Repository secrets (Settings > Secrets and variables > Actions > Repository secrets)
#   2) Environment secrets (Settings > Environments > <env> > Secrets)
#   3) Organization secrets (if available)
#   4) Best practices to avoid leaking sensitive values in logs
#
# Purpose:
# - Use secrets in steps without printing them.
# - Validate whether a secret exists before running a step that needs it.
# - Pass secrets into tools that require authentication (for example: API calls).
#
# Key Concepts and Best Practices:
# 1) Referencing secrets:
#      - Use:  ${{ secrets.MY_SECRET_NAME }}
#      - GitHub masks secret values in logs automatically, but never echo secrets intentionally.
#
# 2) Scope of secrets:
#      - Repository secrets: available to all workflows in that repository.
#      - Environment secrets: available only when a job uses that environment.
#      - Organization secrets: available to selected repos if configured by org admins.
#
# 3) Avoid `if: ${{ secrets.* }}`:
#      - Some validators reject secrets context within `if:`. Prefer shell guards:
#        if [ -n "${{ secrets.API_TOKEN }}" ]; then ...; fi
#
# 4) File-based usage:
#      - If a tool requires a credentials file, write the secret into a file with restricted
#        permissions and remove it when done.
#
# 5) Local testing:
#      - Create placeholder secrets in your repo settings (for example, API_TOKEN="dummy").
#      - This workflow is safe to run without external services; it only checks presence.
#
# Usage:
# - Create one or more secrets before running (optional but recommended):
#     a) Repository secret: API_TOKEN
#     b) Environment secret (for environment "staging"): ENV_ONLY_SECRET
# - Run this workflow manually from the Actions tab and review the logs.
#
# ----------------------------------------------------------------------------------------

name: secrets-example

on:
  workflow_dispatch:            # Manual trigger for learning/testing

permissions:
  contents: read

# Example of default env that is NOT a secret (non-sensitive)
env:
  APP_MODE: "learning"

jobs:
  demo:
    name: Demonstrate secrets usage
    runs-on: ubuntu-latest

    # Using an environment enables access to environment-scoped secrets
    # Create an environment named "staging" in repo Settings to try env secrets.
    environment: staging

    steps:
      # Presence checks for repository, environment, and organization secrets.
      # These do not print the actual secret values.
      - name: Check for repository secret (API_TOKEN)
        run: |
          if [ -n "${{ secrets.API_TOKEN }}" ]; then
            echo "Repository secret API_TOKEN is set."
          else
            echo "Repository secret API_TOKEN is NOT set."
          fi

      - name: Check for environment secret (ENV_ONLY_SECRET)
        run: |
          if [ -n "${{ secrets.ENV_ONLY_SECRET }}" ]; then
            echo "Environment secret ENV_ONLY_SECRET is set (environment: ${{ job.environment.name }})."
          else
            echo "Environment secret ENV_ONLY_SECRET is NOT set or environment not configured."
          fi

      # Organization secret check example (will be unset if you don't have org secrets configured)
      - name: Check for organization secret (ORG_WIDE_SECRET)
        run: |
          if [ -n "${{ secrets.ORG_WIDE_SECRET }}" ]; then
            echo "Organization secret ORG_WIDE_SECRET is set."
          else
            echo "Organization secret ORG_WIDE_SECRET is NOT set."
          fi

      # Guarded example of using a secret in a command (no outbound call executed)
      - name: Use secret in a command (guarded example)
        run: |
          if [ -n "${{ secrets.API_TOKEN }}" ]; then
            echo "API_TOKEN is present; demonstrating a guarded command."
            # Pattern example (disabled by default via 'true ||' to avoid real calls):
            true || curl -sS -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" https://example.invalid/api/ping > /dev/null
          else
            echo "API_TOKEN not set; skipping outgoing request."
          fi

      # Create a temporary credentials file from a secret, then remove it
      - name: Use a file-based credential safely
        run: |
          if [ -n "${{ secrets.API_TOKEN }}" ]; then
          install -m 600 /dev/null ./token.txt
          printf "%s" "${{ secrets.API_TOKEN }}" > ./token.txt
          echo "Created ./token.txt with restricted permissions (600)."

            # Simulate a tool that reads credentials from a file (do not cat the file)
            echo "A tool would read ./token.txt here."

            # Securely remove the credentials file
            shred -u ./token.txt || rm -f ./token.txt
            echo "Temporary credentials file removed."
          else
            echo "API_TOKEN not set; skipping file-based credential flow."
          fi

      # Non-secret envs behave normally and can be printed
      - name: Show non-secret env
        run: |
          echo "APP_MODE is: $APP_MODE"