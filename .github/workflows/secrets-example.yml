# ----------------------------------------------------------------------------------------
# File: .github/workflows/secrets-example.yml
#
# Workflow Name: secrets-example
#
# Description:
# Demonstrates how to reference and use GitHub Actions secrets safely. Shows:
#   1) Repository secrets (Settings > Secrets and variables > Actions > Repository secrets)
#   2) Environment secrets (Settings > Environments > <env> > Secrets)
#   3) Organization secrets (if available)
#   4) Best practices to avoid leaking sensitive values in logs
#
# Purpose:
# - Use secrets in steps without printing them.
# - Validate whether a secret exists before running a step that needs it.
# - Pass secrets into tools that require authentication (for example: API calls).
#
# Key Concepts and Best Practices:
# 1) Referencing secrets:
#      - Use:  ${{ secrets.MY_SECRET_NAME }}
#      - GitHub masks secret values in logs automatically, but never echo secrets intentionally.
#
# 2) Scope of secrets:
#      - Repository secrets: available to all workflows in that repository.
#      - Environment secrets: available only when a job uses that environment.
#      - Organization secrets: available to selected repos if configured by org admins.
#
# 3) Do not log secrets:
#      - Avoid commands like: echo "${{ secrets.MY_SECRET }}"
#      - Prefer presence checks: test -n "${{ secrets.MY_SECRET }}"
#
# 4) File-based usage:
#      - If a tool requires a credentials file, write the secret into a file with restricted
#        permissions and remove it when done.
#
# 5) Local testing:
#      - Create placeholder secrets in your repo settings (for example, API_TOKEN="dummy").
#      - This workflow is safe to run without external services; it only checks presence.
#
# Usage:
# - Create one or more secrets before running (optional but recommended):
#     a) Repository secret: API_TOKEN
#     b) Environment secret (for environment "staging"): ENV_ONLY_SECRET
# - Run this workflow manually from the Actions tab and review the logs.
#
# ----------------------------------------------------------------------------------------

name: secrets-example

on:
  workflow_dispatch:            # Manual trigger for learning/testing

permissions:
  contents: read

# Example of default env that is NOT a secret (non-sensitive)
env:
  APP_MODE: "learning"

jobs:
  demo:
    name: Demonstrate secrets usage
    runs-on: ubuntu-latest

    # Using an environment enables access to environment-scoped secrets
    # Create an environment named "staging" in repo Settings to try env secrets.
    environment: staging

    steps:
      # Presence checks for repository, environment, and organization secrets.
      # These do not print the actual secret values.
      - name: Check for repository secret (API_TOKEN)
        run: |
          if [ -n "${{ secrets.API_TOKEN }}" ]; then
            echo "Repository secret API_TOKEN is set."
          else
            echo "Repository secret API_TOKEN is NOT set."
          fi

      - name: Check for environment secret (ENV_ONLY_SECRET)
        run: |
          if [ -n "${{ secrets.ENV_ONLY_SECRET }}" ]; then
            echo "Environment secret ENV_ONLY_SECRET is set (environment: ${{ job.environment.name }})."
          else
            echo "Environment secret ENV_ONLY_SECRET is NOT set or environment not configured."
          fi

      # Organization secret check example (will be unset if you don't have org secrets configured)
      - name: Check for organization secret (ORG_WIDE_SECRET)
        run: |
          if [ -n "${{ secrets.ORG_WIDE_SECRET }}" ]; then
            echo "Organization secret ORG_WIDE_SECRET is set."
          else
            echo "Organization secret ORG_WIDE_SECRET is NOT set."
          fi

      # Example: using a secret as a header for an API call (command shown, but guarded).
      # Replace the placeholder URL with a real endpoint only when you are ready.
      - name: Use secret in a command (guarded example)
        if: ${{ secrets.API_TOKEN != '' }}
        run: |
          echo "Secret is present; demonstrating a guarded command."
          # Example pattern (disabled by default with 'true ||' to prevent accidental outbound calls):
          true || curl -sS -H "Authorization: Bearer ${{ secrets.API_TOKEN }}" https://example.invalid/api/ping > /dev/null

      # Example: writing a secret to a file for a tool that needs credentials from disk.
      # The file is permission-restricted and removed after use.
      - name: Create temporary credentials file from secret
        if: ${{ secrets.API_TOKEN != '' }}
        run: |
          install -m 600 /dev/null ./token.txt
          printf "%s" "${{ secrets.API_TOKEN }}" > ./token.txt
          echo "Created ./token.txt with restricted permissions (600)."

      - name: Use temporary credentials file (simulated)
        if: ${{ secrets.API_TOKEN != '' }}
        run: |
          # Simulate a tool reading the token from a file.
          # Do not cat the file to logs; pass the path to the tool instead.
          echo "A tool would read ./token.txt here."

      - name: Securely remove credentials file
        if: ${{ secrets.API_TOKEN != '' }}
        run: |
          shred -u ./token.txt || rm -f ./token.txt
          echo "Temporary credentials file removed."

      # Demonstrate passing a secret to a single step as an environment variable.
      # It is safe to pass, but do not echo its value.
      - name: Use secret via step-level env
        if: ${{ secrets.API_TOKEN != '' }}
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
        run: |
          if [ -n "$API_TOKEN" ]; then
            echo "Step-level env received a token (value not printed)."
          fi

      # Show that non-secret envs behave normally and can be printed.
      - name: Show non-secret env
        run: |
          echo "APP_MODE is: $APP_MODE"